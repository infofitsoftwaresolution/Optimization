name: Deploy to EC2

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:  # Allow manual triggering

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies (minimal for CI)
      run: |
        python -m pip install --upgrade pip
        # Use minimal requirements in CI to speed up workflow
        if [ -f "requirements-minimal.txt" ]; then
          pip install -r requirements-minimal.txt
        else
          pip install -r requirements.txt
        fi
    
    - name: Create nginx config with IP from secrets
      run: |
        # Read the nginx template and replace server_name with IP from secrets
        if [ -f "nginx-optimization-app.conf" ]; then
          sed "s/server_name _;/server_name ${{ secrets.EC2_HOST }};/" nginx-optimization-app.conf > nginx-optimization-app-deployed.conf
          echo "‚úÖ Created nginx config with IP: ${{ secrets.EC2_HOST }}"
        else
          echo "‚ö†Ô∏è  nginx-optimization-app.conf not found, skipping nginx config creation"
        fi
    
    - name: Prepare deployment archive
      run: |
        # Create file list excluding unwanted files/directories
        find . -type f \
          ! -path './.git/*' \
          ! -path './.github/*' \
          ! -path '*/__pycache__/*' \
          ! -name '*.pyc' \
          ! -path './.venv/*' \
          ! -path './node_modules/*' \
          ! -name '.env.example' \
          ! -name '.env' \
          ! -name 'deployment.tar.gz' \
          > /tmp/files_to_archive.txt
        
        # Add the nginx config file if it exists
        if [ -f "nginx-optimization-app-deployed.conf" ]; then
          echo "nginx-optimization-app-deployed.conf" >> /tmp/files_to_archive.txt
        fi
        
        # Create tar archive from file list
        tar -czf deployment.tar.gz -T /tmp/files_to_archive.txt
    
    - name: Create .env file from secrets
      run: |
        cat > .env << EOF
        # AWS Configuration
        AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION=${{ secrets.AWS_REGION }}
        
        # Database Configuration
        DB_HOST=${{ secrets.DB_HOST }}
        DB_PORT=${{ secrets.DB_PORT }}
        DB_NAME=${{ secrets.DB_NAME }}
        DB_USER=${{ secrets.DB_USER }}
        DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        DB_SSLMODE=prefer
        # Optional: Master credentials for automatic user creation (if DB_USER doesn't exist)
        DB_MASTER_USER=${{ secrets.DB_MASTER_USER }}
        DB_MASTER_PASSWORD=${{ secrets.DB_MASTER_PASSWORD }}
        # Ensure DB_NAME is not empty or same as DB_USER (fallback to postgres)
        # This will be validated and fixed by the fix script on EC2
        
        # OpenAI API Key (Optional)
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        
        # Streamlit Configuration
        STREAMLIT_BROWSER_GATHER_USAGE_STATS=false
        EOF

    - name: Test SSH connection
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        script: |
          echo "Testing SSH connection..."
          hostname
          echo "‚úÖ Connection successful"

    - name: Deploy code to EC2 via SSH
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        command_timeout: 30s
        script: |
          mkdir -p /home/ec2-user/Optimization
          cd /home/ec2-user/Optimization
          # Backup .env if it exists (will be overwritten by new .env)
          if [ -f ".env" ]; then
            cp .env /tmp/optimization_env_backup
          fi
          # Remove old files (we'll create fresh .venv after extraction)
          find . -mindepth 1 -maxdepth 1 -exec rm -rf {} +

    - name: Copy deployment archive to EC2
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        source: "deployment.tar.gz"
        target: "/home/ec2-user/Optimization/"
        strip_components: 0

    - name: Extract code and restore backups on EC2
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        command_timeout: 60s
        script: |
          cd /home/ec2-user/Optimization
          tar -xzf deployment.tar.gz
          rm deployment.tar.gz
          # Don't restore .venv - we'll create a fresh one to avoid conflicts
          # .env will be deployed in the next step
          
          # Make fix script executable
          if [ -f "scripts/fix-database-connection.sh" ]; then
            chmod +x scripts/fix-database-connection.sh
          fi

    - name: Automatically configure RDS security group
      run: |
        echo "üîß Automatically configuring RDS security group..."
        
        # Extract RDS endpoint from DB_HOST secret
        DB_HOST="${{ secrets.DB_HOST }}"
        EC2_HOST="${{ secrets.EC2_HOST }}"
        AWS_REGION="${{ secrets.AWS_REGION }}"
        
        echo "RDS Endpoint: $DB_HOST"
        echo "EC2 Host: $EC2_HOST"
        echo "AWS Region: $AWS_REGION"
        
        # Get RDS instance identifier
        RDS_ID=$(aws rds describe-db-instances \
          --region "$AWS_REGION" \
          --query "DBInstances[?Endpoint.Address=='$DB_HOST'].DBInstanceIdentifier" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$RDS_ID" ]; then
          echo "‚ö†Ô∏è  Could not find RDS instance for endpoint: $DB_HOST"
          echo "   Skipping automatic security group configuration"
          exit 0
        fi
        
        echo "Found RDS instance: $RDS_ID"
        
        # Get EC2 instance ID from hostname/IP
        # Try to find EC2 instance by public IP or private IP
        EC2_INSTANCE_ID=$(aws ec2 describe-instances \
          --region "$AWS_REGION" \
          --filters "Name=ip-address,Values=$EC2_HOST" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text 2>/dev/null || \
          aws ec2 describe-instances \
          --region "$AWS_REGION" \
          --filters "Name=private-ip-address,Values=$EC2_HOST" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$EC2_INSTANCE_ID" ] || [ "$EC2_INSTANCE_ID" == "None" ]; then
          echo "‚ö†Ô∏è  Could not find EC2 instance for host: $EC2_HOST"
          echo "   Will try to add rule using IP address instead"
          EC2_SG=""
        else
          echo "Found EC2 instance: $EC2_INSTANCE_ID"
          
          # Get EC2 security group
          EC2_SG=$(aws ec2 describe-instances \
            --region "$AWS_REGION" \
            --instance-ids "$EC2_INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].SecurityGroups[0].GroupId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$EC2_SG" ] && [ "$EC2_SG" != "None" ]; then
            echo "Found EC2 security group: $EC2_SG"
          fi
        fi
        
        # Get RDS security groups
        RDS_SGS=$(aws rds describe-db-instances \
          --region "$AWS_REGION" \
          --db-instance-identifier "$RDS_ID" \
          --query 'DBInstances[0].VpcSecurityGroups[*].VpcSecurityGroupId' \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$RDS_SGS" ] || [ "$RDS_SGS" == "None" ]; then
          echo "‚ö†Ô∏è  Could not retrieve RDS security groups"
          exit 0
        fi
        
        echo "RDS Security Groups: $RDS_SGS"
        
        # Configure each RDS security group
        for RDS_SG in $RDS_SGS; do
          echo ""
          echo "Configuring RDS security group: $RDS_SG"
          
          # Check if rule already exists
          EXISTING_RULE=""
          if [ -n "$EC2_SG" ]; then
            EXISTING_RULE=$(aws ec2 describe-security-group-rules \
              --region "$AWS_REGION" \
              --filters "Name=group-id,Values=$RDS_SG" "Name=ip-protocol,Values=tcp" "Name=from-port,Values=5432" "Name=to-port,Values=5432" \
              --query "SecurityGroupRules[?ReferencedGroupInfo.GroupId==\`$EC2_SG\`].SecurityGroupRuleId" \
              --output text 2>/dev/null || echo "")
          fi
          
          if [ -n "$EXISTING_RULE" ] && [ "$EXISTING_RULE" != "None" ]; then
            echo "‚úÖ Security group rule already exists (rule: $EXISTING_RULE)"
          else
            # Try to add rule with EC2 security group as source
            if [ -n "$EC2_SG" ] && [ "$EC2_SG" != "None" ]; then
              echo "Adding rule: PostgreSQL (5432) from EC2 security group $EC2_SG"
              if aws ec2 authorize-security-group-ingress \
                --region "$AWS_REGION" \
                --group-id "$RDS_SG" \
                --protocol tcp \
                --port 5432 \
                --source-group "$EC2_SG" \
                2>/dev/null; then
                echo "‚úÖ Successfully added security group rule"
              else
                ERROR_CODE=$?
                if [ $ERROR_CODE -eq 254 ]; then
                  echo "‚úÖ Rule may already exist (duplicate rule error)"
                else
                  echo "‚ö†Ô∏è  Failed to add rule with security group, trying with IP..."
                  # Fallback: Get EC2 private IP and add rule
                  EC2_PRIVATE_IP=$(aws ec2 describe-instances \
                    --region "$AWS_REGION" \
                    --instance-ids "$EC2_INSTANCE_ID" \
                    --query 'Reservations[0].Instances[0].PrivateIpAddress' \
                    --output text 2>/dev/null || echo "")
                  
                  if [ -n "$EC2_PRIVATE_IP" ] && [ "$EC2_PRIVATE_IP" != "None" ]; then
                    echo "Adding rule: PostgreSQL (5432) from EC2 IP $EC2_PRIVATE_IP/32"
                    if aws ec2 authorize-security-group-ingress \
                      --region "$AWS_REGION" \
                      --group-id "$RDS_SG" \
                      --protocol tcp \
                      --port 5432 \
                      --cidr "$EC2_PRIVATE_IP/32" \
                      2>/dev/null; then
                      echo "‚úÖ Successfully added security group rule with IP"
                    else
                      echo "‚ö†Ô∏è  Could not add security group rule automatically"
                      echo "   Error code: $?"
                    fi
                  fi
                fi
              fi
            else
              echo "‚ö†Ô∏è  EC2 security group not found, cannot add rule automatically"
              echo "   Please add manually: PostgreSQL (5432) from EC2 instance"
            fi
          fi
        done
        
        echo ""
        echo "‚úÖ RDS security group configuration completed"
        echo "   Waiting 10 seconds for changes to propagate..."
        sleep 10

    - name: Deploy .env file to EC2
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        source: ".env"
        target: "/home/ec2-user/Optimization/"
        strip_components: 0

    - name: Clear virtual environment and prepare for fresh install
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        command_timeout: 30s
        script: |
          cd /home/ec2-user/Optimization || exit 1
          echo "üßπ Clearing virtual environment for fresh install..."
          # Remove old virtual environment to avoid conflicts
          if [ -d ".venv" ]; then
            rm -rf .venv
            echo "‚úÖ Removed old virtual environment"
          fi
          # Clear pip cache to free up space
          pip3 cache purge 2>/dev/null || true
          echo "‚úÖ Cleared pip cache"

    - name: Verify deployment and setup environment
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        command_timeout: 30s
        script: |
          cd /home/ec2-user/Optimization || exit 1
          echo "üîç Verifying deployed files..."
          if [ ! -f "requirements-minimal.txt" ] && [ ! -f "requirements.txt" ]; then
            echo "‚ùå ERROR: No requirements file found!"
            exit 1
          fi
          if [ ! -d "src" ]; then
            echo "‚ùå ERROR: src directory not found!"
            exit 1
          fi
          echo "‚úÖ Files verified"

    - name: Setup virtual environment
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        command_timeout: 60s
        script: |
          cd /home/ec2-user/Optimization || exit 1
          echo "üêç Setting up virtual environment..."
          # Remove old venv
          rm -rf .venv
          # Create fresh venv
          python3 -m venv .venv || python3.10 -m venv .venv || python3.9 -m venv .venv || exit 1
          echo "‚úÖ Virtual environment created"

    - name: Install dependencies
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        command_timeout: 5m
        debug: true
        script: |
          set -e
          cd /home/ec2-user/Optimization
          
          # Check if venv exists and has core packages
          if [ -d ".venv" ] && [ -f ".venv/bin/activate" ]; then
            source .venv/bin/activate
            if python3 -c "import streamlit, pandas, boto3" 2>/dev/null; then
              echo "‚úÖ Core packages already installed, skipping installation"
              exit 0
            fi
          fi
          
          # Activate venv
          source .venv/bin/activate
          
          echo "üì¶ Installing dependencies..."
          
          # Upgrade pip (quick, with timeout)
          timeout 30 pip install --upgrade pip --no-cache-dir 2>&1 | head -5 || true
          
          # Determine requirements file
          REQ_FILE="requirements-minimal.txt"
          [ ! -f "$REQ_FILE" ] && REQ_FILE="requirements.txt"
          
          echo "Using $REQ_FILE"
          echo "Installing packages (timeout: 4 minutes)..."
          
          # Install with explicit timeout and error handling
          timeout 240 pip install --no-cache-dir --disable-pip-version-check -r "$REQ_FILE" 2>&1 | tee /tmp/pip_install.log || {
            echo "‚ö†Ô∏è  Installation had issues"
            echo "Checking if core packages are installed..."
            if python3 -c "import streamlit, pandas, boto3" 2>/dev/null; then
              echo "‚úÖ Core packages are available, continuing..."
            else
              echo "‚ùå Core packages missing, showing pip log:"
              tail -20 /tmp/pip_install.log
              exit 1
            fi
          }
          
          echo "‚úÖ Dependencies installed"

    - name: Validate and restart service
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: 22
        command_timeout: 60s
        script: |
          cd /home/ec2-user/Optimization || exit 1
          source .venv/bin/activate || exit 1
          
          # Validate syntax
          echo "üîç Validating Python syntax..."
          python3 -m py_compile src/dashboard.py || exit 1
          echo "‚úÖ Syntax valid"
          
          # Update service file
          if [ -f "streamlit-optimization.service" ]; then
            sudo cp streamlit-optimization.service /etc/systemd/system/
            sudo systemctl daemon-reload
          fi
          
          # Make scripts executable
          chmod +x scripts/start-streamlit-with-secrets.sh 2>/dev/null || true
          
          # Restart service
          sudo systemctl stop streamlit-optimization.service 2>/dev/null || true
          sleep 2
          sudo systemctl start streamlit-optimization.service
          sleep 3
          
          # Check status
          if sudo systemctl is-active --quiet streamlit-optimization.service; then
            echo "‚úÖ Service started successfully"
          else
            echo "‚ùå Service failed to start"
            sudo systemctl status streamlit-optimization.service --no-pager -l | head -10
            exit 1
          fi
          
          # Install and configure Nginx
          echo "üåê Installing and configuring Nginx..."
          
          # Check if nginx is installed
          if ! command -v nginx &> /dev/null; then
            echo "üì¶ Installing Nginx..."
            if command -v yum &> /dev/null; then
              sudo yum install -y nginx || {
                echo "‚ùå Failed to install nginx with yum"
                exit 1
              }
            elif command -v apt-get &> /dev/null; then
              sudo apt-get update
              sudo apt-get install -y nginx || {
                echo "‚ùå Failed to install nginx with apt-get"
                exit 1
              }
            else
              echo "‚ùå Cannot determine package manager for nginx installation"
              exit 1
            fi
            echo "‚úÖ Nginx installed"
          else
            echo "‚úÖ Nginx already installed"
          fi
          
          # Ensure nginx directories exist
          sudo mkdir -p /etc/nginx/conf.d
          sudo mkdir -p /var/log/nginx
          
          # Use the pre-configured nginx file with IP from secrets, or fallback to template
          if [ -f "nginx-optimization-app-deployed.conf" ]; then
            sudo cp nginx-optimization-app-deployed.conf /etc/nginx/conf.d/optimization-app.conf
            EC2_IP=$(grep "server_name" /etc/nginx/conf.d/optimization-app.conf | sed 's/.*server_name \([^;]*\);.*/\1/')
            echo "Using pre-configured nginx with IP: $EC2_IP"
          elif [ -f "nginx-optimization-app.conf" ]; then
            # Fallback: try to get IP from EC2 instance
            EC2_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null || hostname -I | awk '{print $1}' || echo "_")
            sudo cp nginx-optimization-app.conf /etc/nginx/conf.d/optimization-app.conf
            sudo sed -i "s/server_name _;/server_name $EC2_IP;/" /etc/nginx/conf.d/optimization-app.conf || \
            sudo sed -i "s/server_name.*;/server_name $EC2_IP;/" /etc/nginx/conf.d/optimization-app.conf || true
            echo "Using auto-detected IP: $EC2_IP"
          else
            echo "‚ö†Ô∏è  nginx config file not found"
            exit 1
          fi
          
          # Test and restart nginx
          sudo nginx -t && {
            sudo systemctl restart nginx || sudo systemctl start nginx
            sudo systemctl enable nginx
            echo "‚úÖ Nginx configured and restarted"
          } || {
            echo "‚ùå Nginx configuration test failed"
            sudo nginx -t
            exit 1
          }
          
          # Verify nginx is running
          if sudo systemctl is-active --quiet nginx; then
            echo "‚úÖ Nginx is running"
          else
            echo "‚ö†Ô∏è  Nginx is not running, attempting to start..."
            sudo systemctl start nginx
            sleep 2
            if sudo systemctl is-active --quiet nginx; then
              echo "‚úÖ Nginx started successfully"
            else
              echo "‚ùå Failed to start nginx"
              sudo systemctl status nginx --no-pager -l | head -10
              exit 1
            fi
          fi
          
          # Check if services are running
          echo "üìä Service Status:"
          echo "Streamlit: $(sudo systemctl is-active streamlit-optimization.service)"
          echo "Nginx: $(sudo systemctl is-active nginx)"
          echo ""
          echo "üîç Checking ports:"
          sudo netstat -tuln | grep -E "(8501|80)" || ss -tuln | grep -E "(8501|80)"
          echo ""
          echo "üåê Application URLs:"
          EC2_IP=$(grep "server_name" /etc/nginx/conf.d/optimization-app.conf 2>/dev/null | sed 's/.*server_name \([^;]*\);.*/\1/' || echo "IP_NOT_FOUND")
          PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null || echo "UNKNOWN")
          echo "   Nginx config IP: $EC2_IP"
          echo "   Public IP: $PUBLIC_IP"
          echo "   Access at: http://${EC2_IP}/ or http://${PUBLIC_IP}/"
          echo ""
          echo "‚ö†Ô∏è  If connection fails, check:"
          echo "   1. EC2 Security Group allows inbound traffic on port 80 (HTTP)"
          echo "   2. Nginx is running: sudo systemctl status nginx"
          echo "   3. Streamlit is running: sudo systemctl status streamlit-optimization.service"
          
          # Run database connection fix script
          echo ""
          echo "üîß Running database connection fix script..."
          if [ -f "scripts/fix-database-connection.sh" ]; then
            chmod +x scripts/fix-database-connection.sh
            bash scripts/fix-database-connection.sh || {
              echo "‚ö†Ô∏è  Fix script encountered issues, but continuing..."
            }
          else
            echo "‚ö†Ô∏è  Fix script not found, running manual connection test..."
          fi
          
          # Test database connection
          echo ""
          echo "üîç Testing database connection..."
          if [ -f ".env" ]; then
            set -a
            source .env
            set +a
            
            # Fix DB_NAME if it's incorrectly set to username or empty
            if [ "$DB_NAME" == "$DB_USER" ] || [ -z "$DB_NAME" ]; then
              echo "‚ö†Ô∏è  DB_NAME is '$DB_NAME' (same as username or empty), fixing to 'postgres'..."
              DB_NAME="postgres"
              # Update .env file
              sed -i '/^DB_NAME=/d' .env
              echo "DB_NAME=postgres" >> .env
              echo "‚úÖ Updated .env with DB_NAME=postgres"
            fi
            
            if [ -n "$DB_HOST" ] && [ -n "$DB_USER" ] && [ -n "$DB_PASSWORD" ]; then
              echo "Database host: $DB_HOST"
              echo "Database user: $DB_USER"
              echo "Database name: ${DB_NAME:-postgres}"
              echo "Database port: ${DB_PORT:-5432}"
              
              # Install PostgreSQL client if not available
              if ! command -v psql &> /dev/null; then
                echo "üì¶ Installing PostgreSQL client..."
                if command -v yum &> /dev/null; then
                  sudo yum install -y postgresql15 || sudo yum install -y postgresql || echo "‚ö†Ô∏è  Could not install psql"
                elif command -v apt-get &> /dev/null; then
                  sudo apt-get update && sudo apt-get install -y postgresql-client || echo "‚ö†Ô∏è  Could not install psql"
                fi
              fi
              
              # Test PostgreSQL connection
              if command -v psql &> /dev/null; then
                export PGPASSWORD="$DB_PASSWORD"
                EC2_IP=$(hostname -I | awk '{print $1}' || echo "unknown")
                echo "Testing connection from EC2 IP: $EC2_IP"
                echo "Database host: $DB_HOST"
                echo "Database user: $DB_USER"
                echo "Database name: ${DB_NAME:-postgres}"
                
                # Try connection
                CONNECTION_OUTPUT=$(psql -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "$DB_USER" -d "${DB_NAME:-postgres}" -c "SELECT 1;" 2>&1)
                CONNECTION_EXIT_CODE=$?
                
                if [ $CONNECTION_EXIT_CODE -eq 0 ]; then
                  echo "‚úÖ Database connection successful"
                else
                  echo "‚ùå Database connection test failed"
                  echo ""
                  echo "Error output:"
                  echo "$CONNECTION_OUTPUT" | head -3
                  echo ""
                  
                  # Try to automatically create user if master credentials are available
                  if [ -n "$DB_MASTER_USER" ] && [ -n "$DB_MASTER_PASSWORD" ]; then
                    echo "üîß Attempting to automatically create database user..."
                    export PGPASSWORD="$DB_MASTER_PASSWORD"
                    
                    # Check if user exists
                    USER_EXISTS=$(psql -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "$DB_MASTER_USER" -d "postgres" -tAc "SELECT 1 FROM pg_user WHERE usename = '$DB_USER';" 2>/dev/null || echo "0")
                    
                    if [ "$USER_EXISTS" != "1" ]; then
                      echo "User '$DB_USER' does not exist, creating..."
                      
                      # Create user with password
                      CREATE_USER_SQL="CREATE USER \"$DB_USER\" WITH PASSWORD '$DB_PASSWORD';"
                      if psql -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "$DB_MASTER_USER" -d "postgres" -c "$CREATE_USER_SQL" 2>/dev/null; then
                        echo "‚úÖ User '$DB_USER' created successfully"
                        
                        # Grant permissions
                        GRANT_SQL="GRANT CONNECT ON DATABASE ${DB_NAME:-postgres} TO \"$DB_USER\";"
                        psql -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "$DB_MASTER_USER" -d "postgres" -c "$GRANT_SQL" 2>/dev/null || true
                        
                        # Grant schema usage
                        GRANT_SCHEMA_SQL="GRANT USAGE ON SCHEMA public TO \"$DB_USER\"; GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO \"$DB_USER\";"
                        psql -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "$DB_MASTER_USER" -d "${DB_NAME:-postgres}" -c "$GRANT_SCHEMA_SQL" 2>/dev/null || true
                        
                        echo "‚úÖ Permissions granted to user '$DB_USER'"
                        
                        # Test connection again
                        unset PGPASSWORD
                        export PGPASSWORD="$DB_PASSWORD"
                        if psql -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "$DB_USER" -d "${DB_NAME:-postgres}" -c "SELECT 1;" &>/dev/null 2>&1; then
                          echo "‚úÖ Database connection successful after creating user"
                        else
                          echo "‚ö†Ô∏è  User created but connection still fails - check password"
                        fi
                      else
                        echo "‚ö†Ô∏è  Failed to create user automatically"
                      fi
                    else
                      echo "User '$DB_USER' already exists"
                      echo "‚ö†Ô∏è  Connection failed - password may be incorrect"
                    fi
                    unset PGPASSWORD
                  else
                    echo "‚ö†Ô∏è  DB_MASTER_USER and DB_MASTER_PASSWORD not set in secrets"
                    echo "   Cannot automatically create database user"
                    echo ""
                    echo "üîß Manual Fix Steps:"
                    echo ""
                    echo "1. RDS Security Group (should be auto-configured above):"
                    echo "   - Check if security group rule was added automatically"
                    echo "   - If not, add manually: PostgreSQL (5432) from EC2 security group"
                    echo ""
                    echo "2. Database User:"
                    echo "   - Connect to RDS as master user"
                    echo "   - Run: SELECT usename FROM pg_user WHERE usename = '$DB_USER';"
                    echo "   - If user doesn't exist, create it:"
                    echo "     CREATE USER \"$DB_USER\" WITH PASSWORD '$DB_PASSWORD';"
                    echo "     GRANT CONNECT ON DATABASE ${DB_NAME:-postgres} TO \"$DB_USER\";"
                    echo ""
                    echo "3. Verify Credentials:"
                    echo "   - DB_USER: '$DB_USER' (case-sensitive!)"
                    echo "   - DB_PASSWORD: Must match the password set for user '$DB_USER'"
                  fi
                fi
                unset PGPASSWORD
              else
                echo "‚ö†Ô∏è  psql not available, skipping database connection test"
                echo "   Install PostgreSQL client to test database connectivity"
              fi
            else
              echo "‚ö†Ô∏è  Database credentials incomplete in .env file"
              echo "   Required: DB_HOST, DB_USER, DB_PASSWORD"
            fi
          else
            echo "‚ö†Ô∏è  .env file not found, cannot test database connection"
          fi

